# Diplomchik
Дипломная работа (или её какая-то из итераций)

Тут я буду писать код для своей дипломной работы на тему создания системы управления секретами с использованием продуктов с открытых исходным кодом.
Надеюсь, у меня что-то да получится :)

План простой:
1. Написать Proof of concept на питоне
2. Если всё пойдёт нормально, и я справлюсь с первой частью, перепишу на другом языке
3. Написать какое-то пояснение для всего происходящего, что станет в итоге дипломной работой.

Что я сделал:
1. Начал писать классы клиента и сервера
2. Прописал структуру основных запросов и ответов (см. request_example.json)
3. Сделал приветственное сообщение от клиента
4. Прописал скелет ответов сервера клиенту в зависимости от кода запроса (что там за коды можно посмотреть в request_example.json)
5. Прописал скелет отработок ошибок доступа (и возвращение сообщения об этом)
6. Добавил тестовый/ отладочный скрипт, который запускает клиент и сервер на одной машине в двух процессах

Идея появления поля operation_number:
1. Способ учёта запросов: какие запросы находятся в процессе обработки, какие завершились успешно, какие завершились какими-либо ошибками
2. Ещё один способ защиты. Если кто-то попытается отправить перехваченный запрос, то сервер это увидит и разорвёт соединение. В целом, использование шифрования должно этот момент решать, но я решил перестраховаться.
3. Усложнение взлома шифра.

Что дальше:
1. Добавление шифрования пакетов. Планирую использовать RSA (или какую-то другую ассиметрию). Ключи либо будут генерироваться заново во время каждого нового соединения, либо будут лежать в специальной таблице на сервере
2. Добавление базы данных, обслуживающей систему, которая будет содержать следующие таблицы:

а. Таблица пользователей: (имя, хэш пароля, соль, массив ключей доступных пользователю, права доступа на изменение таблицы с ключами/сертификатами)

б. Таблица сертификатов: (номер, сертификат, срок действия)

в. Таблица учёта: (номер операции, имя пользователя, IP, дата/время, статус)

3. Обеспечение работы сервера в параллельном режиме: при каждом новом соединении появится процесс или поток, который будет работать с каждым отдельным соединением, не заставляя остальных клиентов ждать окончания работы с другими клиентами.

